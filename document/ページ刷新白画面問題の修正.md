# ページ刷新白画面問題の修正

## 問題の説明

ページをリフレッシュ（F5キーまたはブラウザの更新ボタン）した際、白い画面が表示される問題が発生していました。

## 根本原因

### 1. 認証状態の同期初期化

元の実装では、`AuthState` プロバイダーが同期的に `false` を返し、その後非同期で実際のログイン状態をチェックしていました：

```dart
@riverpod
class AuthState extends _$AuthState {
  @override
  bool build() {
    _checkLoginState();  // 非同期メソッドを呼び出し
    return false;        // 即座に false を返す
  }

  Future<void> _checkLoginState() async {
    final storage = ref.read(storageServiceProvider);
    final isLoggedIn = await storage.isLoggedIn();
    state = isLoggedIn;  // 後で状態を更新
  }
}
```

この実装により、ページリフレッシュ時に以下の問題が発生していました：

1. 初期状態として `false`（未ログイン）が返される
2. ルーターのリダイレクトロジックが即座に実行される
3. ユーザーがログイン済みでも、ログインページにリダイレクトされる
4. その後、認証状態が `true` に更新されても、すでにリダイレクトが完了している

### 2. ローディング状態の未処理

認証状態の読み込み中にユーザーに何も表示されず、白い画面が表示されていました。

## 解決策

### 1. 非同期認証状態プロバイダーへの変更

`AuthState` を非同期プロバイダーに変更し、初期化が完了するまで待機するようにしました：

```dart
@riverpod
class AuthState extends _$AuthState {
  @override
  Future<bool> build() async {
    // ストレージから認証状態を読み込むまで待機
    final storage = ref.read(storageServiceProvider);
    final isLoggedIn = await storage.isLoggedIn();
    return isLoggedIn;
  }

  Future<bool> login(String username, String password) async {
    await Future.delayed(const Duration(seconds: 1));

    if (username == 'admin' && password == 'admin') {
      final storage = ref.read(storageServiceProvider);
      await storage.saveLoginState(true);
      await storage.saveUsername(username);
      // AsyncValue.data で状態を更新
      state = const AsyncValue.data(true);
      return true;
    }
    return false;
  }

  Future<void> logout() async {
    final storage = ref.read(storageServiceProvider);
    await storage.clearLoginState();
    // AsyncValue.data で状態を更新
    state = const AsyncValue.data(false);
  }
}
```

### 2. ルーターのアーキテクチャ改善

#### 問題：ルーターの再生成

元の実装では、認証状態が変わるたびに新しい `GoRouter` インスタンスが作成されていました：

```dart
@riverpod
GoRouter router(ref) {
  final authState = ref.watch(authStateProvider);  // 状態変化でプロバイダーが再評価される
  
  return GoRouter(  // 新しいインスタンスが作成される
    // ...
  );
}
```

これにより、以下の問題が発生していました：

1. ルーティング履歴が失われる
2. 現在の画面状態がリセットされる
3. "Could not navigate to initial route" エラーが発生する

#### 解決策：AuthNotifier による状態監視

`ChangeNotifier` を継承した `AuthNotifier` クラスを作成し、認証状態の変更を監視します：

```dart
class AuthNotifier extends ChangeNotifier {
  final Ref _ref;
  ProviderSubscription? _subscription;

  AuthNotifier(this._ref) {
    // 認証状態の変更を監視
    _subscription = _ref.listen(
      authStateProvider,
      (_, __) => notifyListeners(),
    );
  }

  @override
  void dispose() {
    _subscription?.close();
    super.dispose();
  }
}
```

そして、`GoRouter` は一度だけインスタンス化し、`refreshListenable` で状態変更を通知します：

```dart
@riverpod
GoRouter router(RouterRef ref) {
  final notifier = AuthNotifier(ref);

  final router = GoRouter(
    initialLocation: '/login',
    refreshListenable: notifier,  // 状態変更時に再評価
    redirect: (context, state) {
      // リダイレクトロジック
    },
    routes: [
      // ルート定義
    ],
  );

  // プロバイダー破棄時にクリーンアップ
  ref.onDispose(notifier.dispose);

  return router;
}
```

### 3. リダイレクトロジックの改善

ルーターで認証状態の `loading`、`data`、`error` の各状態を適切に処理するようにしました：

```dart
@riverpod
GoRouter router(ref) {
  final authState = ref.watch(authStateProvider);

  return GoRouter(
    initialLocation: '/login',
    redirect: (context, state) {
      final isLoginPage = state.matchedLocation == '/login';

      return authState.when(
        data: (isLoggedIn) {
          // 認証状態が確定した場合の処理
          if (!isLoggedIn && !isLoginPage) {
            return '/login';
          }
          if (isLoggedIn && isLoginPage) {
            return '/home';
          }
          return null;
        },
        loading: () => null,  // ローディング中はリダイレクトしない
        error: (_, __) => '/login',  // エラー時はログインページへ
      );
    },
    routes: [
      // ... ルート定義
    ],
  );
}
```

### 4. アプリケーションレベルでのローディング画面追加

アプリケーションのルートウィジェットで認証状態のローディング中に適切な画面を表示するようにしました：

```dart
class App extends ConsumerWidget {
  const App({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final authState = ref.watch(authStateProvider);

    return authState.when(
      data: (_) {
        // 認証状態が確定したらルーターを構築
        final router = ref.watch(routerProvider);
        return MaterialApp.router(
          title: 'LSP System',
          theme: ThemeData(
            colorScheme: ColorScheme.fromSeed(
              seedColor: Colors.blue,
              brightness: Brightness.light,
            ),
            useMaterial3: true,
          ),
          darkTheme: ThemeData(
            colorScheme: ColorScheme.fromSeed(
              seedColor: Colors.blue,
              brightness: Brightness.dark,
            ),
            useMaterial3: true,
          ),
          routerConfig: router,
        );
      },
      loading: () => MaterialApp(
        // ローディング中は専用の画面を表示
        home: Scaffold(
          body: Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                const LoadingIndicator(),
                const SizedBox(height: 16),
                Text(
                  '読み込み中...',
                  style: Theme.of(context).textTheme.bodyLarge,
                ),
              ],
            ),
          ),
        ),
      ),
      error: (error, stack) => MaterialApp(
        // エラー時はエラー画面を表示
        home: Scaffold(
          body: Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                const Icon(Icons.error_outline, size: 48, color: Colors.red),
                const SizedBox(height: 16),
                Text(
                  '初期化エラー: $error',
                  style: Theme.of(context).textTheme.bodyLarge,
                  textAlign: TextAlign.center,
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}
```

## 変更されたファイル

1. **lib/features/auth/providers/auth_provider.dart**
   - `AuthState` を非同期プロバイダーに変更
   - `build()` メソッドが `Future<bool>` を返すように変更
   - `login()` と `logout()` メソッドで `AsyncValue.data` を使用するように変更

2. **lib/router/app_router.dart**
   - `AuthNotifier` クラスを追加して認証状態の変更を監視
   - `GoRouter` が一度だけインスタンス化されるように変更（以前は認証状態が変わるたびに再生成されていた）
   - `refreshListenable` を使用してルーターに状態変更を通知
   - リダイレクトロジックで `authState.when()` を使用して各状態を処理
   - ローディング中はリダイレクトを実行しないように変更
   - プロバイダーの破棄時に `AuthNotifier` を適切にクリーンアップ

3. **lib/app.dart**
   - 認証状態に基づいて適切な画面を表示するように変更
   - ローディング画面とエラー画面を追加

## 改善の効果

### 修正前
- ページリフレッシュ時に白い画面が表示される
- ログイン済みユーザーがログインページにリダイレクトされる
- ユーザーエクスペリエンスが悪い

### 修正後
- ページリフレッシュ時にローディング画面が表示される
- 認証状態が正しく読み込まれてからルーティングが実行される
- ログイン済みユーザーはそのままログイン状態を維持できる
- スムーズなページ遷移が実現

## 動作確認

以下の操作で問題が解決されたことを確認できます：

1. アプリケーションを起動
2. ログインページで「admin / admin」でログイン
3. ホームページまたは任意の機能ページに移動
4. ブラウザの更新ボタンを押す（または F5 キー）
5. ページが正しく表示され、ログイン状態が維持されていることを確認

## 注意事項

- この修正により、アプリケーション起動時に短時間のローディング画面が表示されます
- これはユーザーエクスペリエンスの改善であり、認証状態を正しく読み込むために必要な動作です
- ローディング時間は通常数百ミリ秒以内で完了します

## 技術的な詳細

### AsyncNotifier のメリット

Riverpod の `AsyncNotifier` を使用することで：

1. **型安全性**: `AsyncValue<T>` により、loading、data、error の各状態を型安全に処理できる
2. **エラーハンドリング**: 非同期処理のエラーを自動的にキャッチして `error` 状態として扱える
3. **リアクティブ性**: 状態の変化が自動的に UI に反映される
4. **コードの簡潔性**: `when` メソッドで各状態を簡潔に処理できる

### ルーターとの統合

GoRouter と Riverpod を組み合わせることで：

1. **宣言的なルーティング**: 認証状態に基づいて自動的にリダイレクトされる
2. **状態の一元管理**: 認証状態を一箇所で管理し、複数の場所から参照できる
3. **テスタビリティ**: プロバイダーをモックすることでテストが容易になる

## テスト手順

修正が正しく機能することを確認するには、以下の手順でテストしてください：

### 1. アプリケーションの起動

```bash
flutter run -d web-server
```

または

```bash
flutter run -d chrome
```

### 2. ログイン

1. ブラウザでアプリケーションを開く
2. ログインページで「admin / admin」を入力してログイン
3. ホームページが表示されることを確認

### 3. ページリフレッシュのテスト

1. ホームページまたは任意の機能ページに移動
2. ブラウザのアドレスバーのURLを確認（例：`http://localhost:8080/home/personal-services/application`）
3. ブラウザの更新ボタンをクリック（または F5 キーを押す）
4. **期待される動作**：
   - 短時間のローディング画面が表示される
   - その後、同じページが正しく表示される
   - ログイン状態が維持されている
   - 白い画面や「Could not navigate to initial route」エラーが表示されない

### 4. 異なる画面でのテスト

複数の画面でリフレッシュをテストして、すべてのルートで正しく動作することを確認：

- `/home` - ホームページ
- `/home/workforce-forecast` - 必要人時予測
- `/home/progress/personal` - 個人作業実績管理
- `/home/analytics/budget-analysis` - 予算計画実績契約分析
- `/home/personal-services/application` - 応募

### 5. ログアウト後のテスト

1. ログアウトする
2. ログインページに戻ることを確認
3. ブラウザで `/home` に直接アクセスを試みる
4. **期待される動作**：自動的にログインページにリダイレクトされる

## トラブルシューティング

### ブラウザのコンソールエラー

もしブラウザのコンソールにエラーが表示される場合：

1. ブラウザのキャッシュをクリア
2. アプリケーションを再起動
3. コードジェネレーターを再実行：

```bash
flutter pub run build_runner build --delete-conflicting-outputs
```

### ホットリロードが機能しない

大きな構造変更を行ったため、ホットリロードではなくホットリスタートが必要です：

- Flutterの実行中に `R` キーを押す
- または、アプリケーションを完全に再起動する

## まとめ

この修正により、ページリフレッシュ時の白画面問題が完全に解決されました。主な改善点：

1. **非同期認証状態プロバイダー**: 認証状態の初期化を正しく処理
2. **ルーターのアーキテクチャ改善**: `GoRouter` の再生成を防ぎ、状態変更時に `refreshListenable` で通知
3. **適切な状態処理**: loading、data、error の各状態を適切に処理
4. **ユーザーエクスペリエンスの向上**: ローディング画面とエラー画面の追加

これらの変更により、アプリケーションの起動フローがより堅牢になり、ユーザーエクスペリエンスが大幅に改善されました。

